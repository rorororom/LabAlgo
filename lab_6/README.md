# Laba6

## Это шестая лаба по алгосам на тему "Деревья"

### Что было ~~дальше~~ сделано
Написана реализация наивного дерева поиска. Сделано 100000 вставок случайных элементов. Засечено время работы. Сделано 50000 удалений. Засечено время работы.

### Наивное дерево поиска
Binary Search tree - структура данных (aka двоичное дерево), для любого узла которого выполняются следующие свойства:

- Оба узла поддерева являются двоичными деревьями поиска;
- Все значения ключей левого поддерева меньше ключа узла;
- Все значения ключей правого поддерева больше ключа узла.


### AVL-дерево
AVL-Tree — сбалансированное двоичное дерево поиска, в котором поддерживается следующее свойство:
- Для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

### Декартово дерево
Декартово дерево — это структура данных, сочетающая в себе двоичное дерево и двоичную кучу. Хранит пары (x, y), где для ключа x служит бинарным деревом поиска, а для приоритета y — двоичной кучей.

### Splay дерево
Splay-tree — это двоичное дерево поиска. Оно позволяет находить быстрее те данные, которые использовались недавно.

### Skip-List
Skip-List - вероятностная структура данных, основанная на нескольких параллельных отсортированных связных списках с эффективностью, сравнимой с двоичным деревом (порядка O(log n) среднее время для большинства операций).


### Вывод про вставку и удаление случайной/отсортированной последовательности:

|               Действие                 | Наивное дерево поиска | AVL-дерево       |
|:--------------------------------------:|:---------------------:|:-----------------|
| Вставка случайных элеметов         (c) |    0.031470           |        -         |
| Удаление случайных элементов       (c) |    0.020075           |        -         |
| Вставка отсортированных элементов  (c) |    0.178969           | 0.004541         |
| Удаление отсортированных элементов (c) |    0.000053           | 0.000027         |

#### Результаты:
Вставка 10000 элементов в отсортированном порядке в наивное дерево поиска это долго и плохо, так как дерево превращается в структуру, напоминающую "бамбук". Каждый новый элемент добавляется как лист последнего узла, получается высота дерева становится равной количеству его элементов. Время вставки каждого нового элемента увеличивается, так как требуется пройти через все узлы дерева. Это делает общее время вставки всех элементов порядка $O(n^2)$ , где n — количество вставок.

AVL-дерево, которое является сбалансированным двоичным деревом поиска, поддерживает свою структуру с балансировкой. Благодаря этому, высота AVL-дерева логарифм от количества вставленных значений. Таким образом, вставка 10000 отсортированных элементов займет времени порядка $O(n \log n)$, что значительно эффективнее по сравнению с обычным двоичным деревом поиска.

### Результаты по 10 тестам

### Сравнение операции insert:

<img src = "./Pictures/Figure_1.png" width="500" height="250">

### Сравнение операции delete:

<img src = "./Pictures/Figure_2.png" width="500" height="250">

Так как skip list слишком долгий, что не видно четко другие результаты, то вот график без него:

<img src = "./Pictures/Figure_3.png" width="500" height="250">

### Вывод
#### Вставка
1. **AVL-дерево** получилось быстрее всех. Это объясняется тем, что AVL-дерево строго поддерживает балансировку после каждой операции вставки и высота дерева остается логарифмической относительно числа узлов.

2. **Splay-дерево** и **Skip List** показывают схожую скорость. Splay-деревья автоматически перемещают часто доступные элементы ближе к корню, что может ускорить последующие операции с этими элементами, но начальное заполнение такого дерева может быть не таким быстрым. Skip List, который использует многоуровневую структуру для облегчения доступа к элементам, также демонстрирует хорошую скорость, но может быть менее предсказуем в плане производительности из-за использования случайности в процессе построения своих уровней. Как будто они должны были быть дольше всех..

3. **Декартово дерево** чуть медленнее. Случайность в балансировке Treap может вести к менее предсказуемому времени по сравнению с жестко балансируемым деревом AVL.

#### Удаление

Вероятнее всего Skip-List дольше всех из-за кешей.

ПРО КЕШИ: Современные процессоры используют кэширование для ускорения доступа к данным. Кэши организованы таким образом, чтобы эффективно работать с последовательными или хорошо локализованными данными. В Skip List элементы, которые нужно обновить при удалении, могут быть распределены по разным частям памяти. Это приводит к кэш-промахам, когда процессор загружает данные из основной памяти, а не из быстрых кэшей. Каждый такой промах увеличивает время выполнения операции.

Из-за того, что в splay дерево более популярные элементы ближе к корню, то при обращении к таким элементам они будут доступны быстрее. Таким образом, при удалении элемента, который был недавно использован, поэтому удаление может быть быстрее.

Также splay деревья не требуют жесткой балансировки, это может привести к тому, что операция удаления в Splay-деревьях требует меньше операций перебалансировки и, следовательно, может быть быстрее.

